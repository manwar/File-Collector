# PODNAME: File::Collector

=head1 OVERVIEW

C<File::Collector> and its companion module C<File::Collector::Processor> are
base classes designed to make it easier to create custom modules for classifying
and processing a collection of files as well as generating and processing data
related to files in the collection.

For example, let's say you need to import raw files from one directory into some
kind of repository. Let's say that files in the directory need to be filtered
and the content of the files needs to be parsed, validated, rendered and/or
changed before getting imported. Complicating things further, let's say that the
name and location of the file in the target repository is dependent upon the
content of the files in some way. Oh, and you also have to check to make sure
the file hasn't already been imported.

This kind of task can be acomplished with a series of one-off scripts that
process and import your files with each script producing output suitable for the
next script. But if such imports involve a high level of complexity, running
separate scripts for each processing stage can be slow, tedious, error-prone and
a headache to maintain and organize.

The C<File::Collector> and C<File::Collector::Processor> base modules can help
you set up a chain of modules to combine a series of workflows into a single
logical package that will make complicated file processing more robust,
testable, and easier code.

=head1 SYNOPSIS

First, create a C<Collector> class for classifying your files into different
collections which will be processed by your C<Processor> class later on.

  pakcage File::Collector::YourCollector;
  use strict; use warnings;

  # This package contains your processing methods (see below)
  use File::Collector::YourCollector::Processor;

  # This object will be used to store information about the files in our
  # collection so it can be used by any of our classes.
  use SomeObject;

  # The parent of this class is another File::Collector class. This is how you
  # chain your Collectors and Processors together.
  use parent File::Collector::ParentCollector;

  # Add the names of your file collections into the C<_init_processors> method.
  # The files in the collection are placed into a C<Processor> object that share
  # the same name as your collection. In the example below, we add two
  # collections, "good" and "bad."
  sub _init_processors {
    my $s = shift;
    $s->SUPER::_init_processors( @_, qw ( good bad ) );
  }

  # Next we add a C<_classify_file> method that is called once for each new file
  # added when constructing our C<Collector> object. The primary job of this
  # method is to classify your files and create objects which can be associated
  # with individual files.
  sub _classify_file {
    my $s = shift;

    # Allow parent classes to classify the files first
    $s->SUPER::_classify_file;

    # First, we will create an object and associate that object with our file
    # using the C<_add_obj> method. There is no requirement that you create
    # objects but they will make data about your file available to your
    # processing classes. We recommend offloading as much logic as possible to
    # objects to keep your classes easy and simple to follow.

    # Note the C<selected> method which is a handy way to return the full path
    # to the file currently being processed by C<_classify_file>.
    my $data = SomeObject->new( $s->selected );
    $s->_add_obj('data', $data);

    # Now that we know something about our file, you can classify the files
    # according to the criteria of your choosing.
    # to a processor category
    if ( $data->{has_good_property} ) {
      $s->_classify('good');
    } else {
      $s->_classify('bad');
    }
  }

  # Finally, the _run_processes method contains method calls to your
  # C<Processor> methods.
  sub _run_processes {
    my $s = shift;

    # run processes of parent classes first
    $s->SUPER::_run_processes;

    # Now we run methods on the files in our collection. The C<good_file> method
    # returns the collection of files classified as "good" and the C<do> method
    # is a method that automatically iterates over the files. The C<modify>
    # method is one of the methods in our C<Processor> classes (see below).
    $s->good_files->do->modify;

    # Run methods on files classified as "bad"
    $s->bad_files->do->fix;
    $s->bad_files->do->modify;

    # You can call methods found in any of your parent C<Processor> classes.
    $s->good_files->do->move;
    $s->bad_files->do->move;
  }

Now we create the Processor class to contain the methods that processing the
files or data in our objects. Your C<Processor> class must have the same package
name as the C<Collector> class with "::Processor" tacked on to the end.

  package File::Collector::YourCollector::Processor;
  use parent 'File::Collector::Processor';

  # This method is run once for each file in a collection when we use the C<do>
  # method.
  sub modify {
    my $s = shift;

    # Skip the file if it has already been processed.
    next if ($s->attr_defined ( 'data', 'processed' ));

    # Properties of objects added by Collector classes can be easily accessed.
    my @values = $s->get_obj_prop ( 'header', 'header_values' );

    # You can call methods found insided objects, too. Here we run the
    # add_header() method on the data object and pass on values to it.
    $s->obj_meth ( 'data', 'add_header', \@values );
  }

  # Code for fixing "bad" files goes here.
  sub fix {
    ...
  }

Now that your classes have been created, you can run all of your collectors and
processors with a single line of code:

   my $collector = File::Collector::YourClassifier->new('my/dir', { recurse => 0 });

   # The C<$collector> object has methods you can call.
   $collector->get_count; # returns total number of files in the collection

   # Convenience methods with a little under-the-hood magic make it painless to
   # iterate over files and run methods on them.
   while ($collector->next_good_file) {
     $collector->print_short_name;
   }

   # Iterator objects, which are really the same thing as C<Processor> objects,
   # can be easily generated.
   my $iterator = $s->get_good_files;
   while ( $iterator->next ) {
     # run C<Processor> methods and do other stuff to "good" files
     $iterator->modify_file;
   }

=head1 DESCRIPTION

=head2 Regular Collector Methods

The methods below are found in the C<File::Collector> class. Be sure to look at
the L<File::Collector::Base> class for useful methods when iterating over files
in a collection.

=method new( 'dir', 'file', ..., \%opts  )
=method new( 'dir', 'file', ..., )

  my $collector = File::Collector::MyClassifier->new('my/directory', { recurse => 0 } );

Creates a C<Collector> object to collect files in the argument list. An option
hash can be supplied to turn directory recursion off with C<recurse> which is
set to true by default. Once created, the C<Collector> immediately goes to work
collecting and processing the files according to the workflow you created with
your custom modules.

C<new> returns an object which contains all the files, their processing classes,
and any data you have associated with the files. This object has serveral
methods that can be used to inspect the object.

=method add_resources( 'dir', 'file' )

  $collector->add_resources( 'file1', 'dir2', ... );

Adds additional file resources to the collection and processes them. This method
accepts no option hash.

=method get_count()

  $collector->get_count;

Returns the total number of files in the collection.

=method get_files()

  my @all_files = $collector->get_files;

Returns a list of the full path of each file in the collection.

=method get_file($file)

  my $file = $collector->get_files('/full/path/to/file.txt');

Returns has reference of the data an objects associated with a file.

=method list_files_long()

Prints the full path names of each file in the collection, sorted alphabetically, to STDOUT.

=method list_files()

Same as C<list_files_long> but prints the files' paths relative to the top level
directory shared by all the files in the collections.

=method

=head2 Private Collector Methods for Child Classes

The following methods, though private, are meant to be overridden by the child
classes of C<File::Collector> that you provide.

=method _init_processors( @_, @your_custom_file_categories )

  sub _init_processors {
    my $s = shift;
    $s->SUPER::_init_processor( @_, ( 'category_1', 'category_2' ) );
  }

Adds categories for your Collector class. Internally, this method adds a new
Processor object to the C<Collector> so that C<Processor> methods found in your
custom C<Processor> class can be run on your files. This method is run once upon
C<Collector> object construction.

This method should call the C<SUPER::_init_processors> method and pass C<@_>
to it along with your custom list of categories.

=method _classify_file()

  sub _classify_file {
    my $s = shift;
    $s->SUPER::_classify_file();

    # File classifying and analysis logic goes here
  }

Use this method to classify your files and associate objects with your files
using the methods provided by the C<Collector> class. This method is run
once for each file in the collection.

See the L<File::Collector::Base> documentation for methods for accessing and
associating information about the file which you can use inside of this method.

This method should call the C<SUPER::_classify_file> method so that any parent classes can classify and add file processors to the C<Collector> object.

=method _classify( $category_name )

This method is typically called from within the C<_classify_file> method. It
adds the file currently getting pocessed to a collection of C<$category_name>
files contained within a C<Processor> object which, in turn, belongs to the
C<Collector> object.  The C<$category_name> must match one of the processor
names provided by the C<_init_processor> methods.

=method _add_obj( $object_name, $object )

Like the C<_classify> method, this method is typically called from within the
C<_classify_file> method. It associates the object specified by C<$object> to an
arbitrary name, specified by C<$object_name>, with the file currently getting
processed.

=method _run_processes()

  sub _run_processes {
    my $s = shift;
    $s->SUPER::_run_processes();

    # Processor method calls go here
  }

Make method calls associated with the various C<Processor>s inside of the
C<_run_processes> method. Note the inclusion of the C<SUPER::_run_processes> so
method call so parent classes can run their processor methods first.

=head1 CONFIGURATION AND ENVIRONMENT

Requires no configuration files or environment variables.

=head1 DEPENDENCIES


=head1 SEE ALSO
