# NAME

File::Collector

# VERSION

version 0.014

# OVERVIEW

`File::Collector` and its companion module `File::Collector::Processor` are
base classes designed to make it easier to create custom modules for classifying
and processing a collection of files as well as generating and processing data
related to files in the collection.

For example, let's say you need to import raw files from one directory into some
kind of repository. Let's say that files in the directory need to be filtered
and the content of the files needs to be parsed, validated, rendered and/or
changed before getting imported. Complicating things further, let's say that the
name and location of the file in the target repository is dependent upon the
content of the files in some way. Oh, and you also have to check to make sure
the file hasn't already been imported.

This kind of task can be acomplished with a series of one-off scripts that
process and import your files with each script producing output suitable for the
next script. But if such imports involve a high level of complexity, running
separate scripts for each processing stage can be slow, tedious, error-prone and
a headache to maintain and organize.

The `File::Collector` and `File::Collector::Processor` base modules can help
you set up a chain of modules to combine a series of workflows into a single
logical package that will make complicated file processing more robust,
testable, and easier code.

# SYNOPSIS

There are three steps to using `File::Collector`. First, you create your
`Collector` classes, one for each stage of your file processing. Next, you
create `Processor` classes, one for each of your `Collector` classes. Finally,
you write a simple script to actually do the processing.

\# Step 1: Create the `Collector` classes

    package File::Collector::YourCollector;
    use strict; use warnings;

    # Get access to methods provided by the base class
    use parent 'File::Collector';

    # This package contains the processing methods associated with your
    # C<Collector (see below).
    use File::Collector::YourCollector::Processor;

    # Objects can store information about the files in the collection which
    # can be accessed by other other C<Collector> and C<Processor> classes.
    use SomeObject;

    # Add the names of your file collections with the C<_init_processors> method.
    # The file collection names are used to create names for the C<Processor>
    # objects that store the paths to files and other data about the files.
    # In the example below, we add two file collections, "good" and "bad."
    sub _init_processors {
      return qw ( good bad );
    }

    # Next we add a C<_classify_file> method that is called once for each file
    # added when constructing our C<Collector> object. The primary job of this
    # method is to classify your files and create objects which can be associated
    # with individual files.
    sub _classify_file {
      my $s = shift;

      # First, we create an object and associate it with our file using the
      # C<_add_obj> method. There is no requirement that you create objects but
      # they will make data about your file easily available to your classes. We
      # recommend offloading as much logic as possible to objects to keep your
      # classes easy and simple to follow.

      # Note the use of the C<selected> method which is a handy way to return the
      # full path to the file currently being processed by C<_classify_file>.
      my $data = SomeObject->new( $s->selected );
      $s->_add_obj('data', $data);

      # Now that we know something about our file, we can classify the files
      # according to any criteria of your choosing.
      # to a processor category
      if ( $data->{has_good_property} ) {
        $s->_classify('good');
      } else {
        $s->_classify('bad');
      }
    }

    # Finally, the _run_processes method contains method calls to your
    # C<Processor> methods.
    sub _run_processes {
      my $s = shift;

      # Below are the methods we can run on the files in our collection. The
      # C<good_files> method returns the collection of files classified as "good"
      # and the C<do> method is a method that automatically iterates over the
      # files. The C<modify> method is one of the methods in our C<Processor>
      # classes (see below).
      $s->good_files->do->modify;

      # Run methods on files classified as "bad"
      $s->bad_files->do->fix;
      $s->bad_files->do->modify;

      # You can call methods found in any of the earlier C<Processor> classes you
      # run in your chain.
      $s->good_files->do->move;
      $s->bad_files->do->move;
    }

Step #2: Create your `Processor` classes.

    # Your C<Processor> class must have the same package name as the C<Collector>
    # class with C<::Processor> tacked on to the end.
    package File::Collector::YourCollector::Processor;
    use parent 'File::Collector::Processor';

    # This method is run once for each file in a collection when we use the C<do>
    # method.
    sub modify {
      my $s = shift;

      # Skip the file if it has already been processed.
      next if ($s->attr_defined ( 'data', 'processed' ));

      # Properties of objects added by Collector classes can be easily accessed.
      my @values = $s->get_obj_prop ( 'header', 'header_values' );

      # You can call methods found insided objects, too. Here we run the
      # add_header() method on the data object and pass on values to it.
      $s->obj_meth ( 'data', 'add_header', \@values );
    }

    # Code for fixing "bad" files goes here.
    sub fix {
      ...
    }

Once your classes have been created, you can run all of your collectors and
processors simply by constructing a `Collector` object.

The constructor takes three types of arguments: a list of the files and/or
directories you want to collect; an array of the names of the `Collector`
classes you wish to use in the order you wish to employ them; and finally, an
optional option hash.

    my $collector = File::Collector::YourClassifier->new(
      # The first arguments are a list of resources to be added
      'my/dir',

      # The second argument is an array of C<Collector> class names in the order
      # you want them to run
      [ 'File::Collector::First', 'File::Collector::YourCollector'],

      # An optional hash argument for options can be supplied
      { recurse => 0 });

    # The C<$collector> object has methods you can call.
    $collector->get_count; # returns total number of files in the collection

    # Convenience methods with a little under-the-hood magic make it painless to
    # iterate over files and run methods on them.
    while ($collector->next_good_file) {
      $collector->print_short_name;
    }

    # Iterator objects, which are really the same thing as C<Processor> objects,
    # can be easily generated.
    my $iterator = $s->get_good_files;
    while ( $iterator->next ) {
      # run C<Processor> methods and do other stuff to "good" files
      $iterator->modify_file;
    }

# DESCRIPTION

## Collector Methods

The methods below are found in the `File::Collector` class. Be sure to look at
the [File::Collector::Base](https://metacpan.org/pod/File::Collector::Base) class for useful methods when iterating over files
in a collection.

## 

### new( 'dir', 'file', ..., \[ 'My::Custom::Class::One', ... \], \\%opts )

### new( 'dir', 'file', ..., \[ 'My::Custom::Class::One', ... \] )

    my $collector = File::Collector::MyClassifier->new('my/directory', { recurse => 0 } );

Creates a `Collector` object to collect files in the argument list. An option
hash can be supplied to turn directory recursion off with `recurse` which is
set to true by default. Once created, the `Collector` immediately goes to work
collecting and processing the files according to the workflow you created with
your custom modules.

`new` returns an object which contains all the files, their processing classes,
and any data you have associated with the files. This object has serveral
methods that can be used to inspect the object.

### add\_resources( 'dir', 'file' )

    $collector->add_resources( 'file1', 'dir2', ... );

Adds additional file resources to the collection and processes them. This method
accepts no option hash.

### get\_count()

    $collector->get_count;

Returns the total number of files in the collection.

### get\_files()

    my @all_files = $collector->get_files;

Returns a list of the full path of each file in the collection.

### get\_file($file)

    my $file = $collector->get_files('/full/path/to/file.txt');

Returns a reference of the data and objects associated with a file.

### list\_files\_long()

Prints the full path names of each file in the collection, sorted alphabetically, to STDOUT.

### list\_files()

Same as `list_files_long` but prints the files' paths relative to the top level
directory shared by all the files in the collections.

### \_init\_processors()

    sub _init_processors {
      return qw ( 'category_1', 'category_2' );
    }

Adds categories for your Collector class. Internally, this method adds a new
Processor object to the `Collector` so that `Processor` methods found in your
custom `Processor` class can be run on your files. This method is run once upon
`Collector` object construction.

### \_classify\_file()

    sub _classify_file {
      my $s = shift;

      # File classifying and analysis logic goes here
    }

Use this method to classify your files and associate objects with your files
using the methods provided by the `Collector` class. This method is run
once for each file in the collection.

See the [File::Collector::Base](https://metacpan.org/pod/File::Collector::Base) documentation for methods for accessing and
associating information about the file which you can use inside of this method.

### \_run\_processes()

    sub _run_processes {
      my $s = shift;

      # Processor method calls go here
    }

Make method calls associated with the various `Processor`s inside of the
`_run_processes` method.

### \_classify( $category\_name )

This method is typically called from within the `_classify_file` method. It
adds the file currently getting pocessed to a collection of `$category_name`
files contained within a `Processor` object which, in turn, belongs to the
`Collector` object.  The `$category_name` must match one of the processor
names provided by the `_init_processor` methods.

### \_add\_obj( $object\_name, $object )

Like the `_classify` method, this method is typically called from within the
`_classify_file` method. It associates the object specified by `$object` to an
arbitrary name, specified by `$object_name`, with the file currently getting
processed.

# BUGS AND LIMITATIONS

You can make new bug reports, and view existing ones, through the
web interface at [https://github.com/sdondley/File-Collector/issues](https://github.com/sdondley/File-Collector/issues).

# INSTALLATION

See perlmodinstall for information and options on installing Perl modules.

# SEE ALSO

# AUTHOR

Steve Dondley <s@dondley.com>

# COPYRIGHT AND LICENSE

This software is copyright (c) 2019 by Steve Dondley.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
